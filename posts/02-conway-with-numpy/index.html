<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Conway's Game of Life in Just a Few Lines with Python's Scientific Stack | Will Duke's Blog</title><meta name=keywords content="python,scipy,numpy,matplotlib,conway"><meta name=description content="Awhile back, I came across a video from one of my favorite channels, Numberphile, on Conway&rsquo;s Game of Life. Turns out, it&rsquo;s not a game you can actually &ldquo;play,&rdquo; beyond setting the initial state of a simulation that progresses via a set of very simple rules. Devised by the British mathematician John Conway in 1970, the game is composed of a grid of cells, each of which can be alive or dead."><meta name=author content="Will Duke"><link rel=canonical href=https://willduke.github.io/posts/02-conway-with-numpy/><link crossorigin=anonymous href=/assets/css/stylesheet.53d97598899667e064f3ce6a3016e01bf8d751bc9fa264a5e95bbdcbee247dfa.css integrity="sha256-U9l1mImWZ+Bk885qMBbgG/jXUbyfomSl6Vu9y+4kffo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://willduke.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://willduke.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://willduke.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://willduke.github.io/apple-touch-icon.png><link rel=mask-icon href=https://willduke.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><meta property="og:title" content="Conway's Game of Life in Just a Few Lines with Python's Scientific Stack"><meta property="og:description" content="Awhile back, I came across a video from one of my favorite channels, Numberphile, on Conway&rsquo;s Game of Life. Turns out, it&rsquo;s not a game you can actually &ldquo;play,&rdquo; beyond setting the initial state of a simulation that progresses via a set of very simple rules. Devised by the British mathematician John Conway in 1970, the game is composed of a grid of cells, each of which can be alive or dead."><meta property="og:type" content="article"><meta property="og:url" content="https://willduke.github.io/posts/02-conway-with-numpy/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-03T21:35:20-04:00"><meta property="article:modified_time" content="2022-05-03T21:35:20-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Conway's Game of Life in Just a Few Lines with Python's Scientific Stack"><meta name=twitter:description content="Awhile back, I came across a video from one of my favorite channels, Numberphile, on Conway&rsquo;s Game of Life. Turns out, it&rsquo;s not a game you can actually &ldquo;play,&rdquo; beyond setting the initial state of a simulation that progresses via a set of very simple rules. Devised by the British mathematician John Conway in 1970, the game is composed of a grid of cells, each of which can be alive or dead."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://willduke.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Conway's Game of Life in Just a Few Lines with Python's Scientific Stack","item":"https://willduke.github.io/posts/02-conway-with-numpy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Conway's Game of Life in Just a Few Lines with Python's Scientific Stack","name":"Conway\u0027s Game of Life in Just a Few Lines with Python\u0027s Scientific Stack","description":"Awhile back, I came across a video from one of my favorite channels, Numberphile, on Conway\u0026rsquo;s Game of Life. Turns out, it\u0026rsquo;s not a game you can actually \u0026ldquo;play,\u0026rdquo; beyond setting the initial state of a simulation that progresses via a set of very simple rules. Devised by the British mathematician John Conway in 1970, the game is composed of a grid of cells, each of which can be alive or dead.","keywords":["python","scipy","numpy","matplotlib","conway"],"articleBody":"Awhile back, I came across a video from one of my favorite channels, Numberphile, on Conway’s Game of Life. Turns out, it’s not a game you can actually “play,” beyond setting the initial state of a simulation that progresses via a set of very simple rules. Devised by the British mathematician John Conway in 1970, the game is composed of a grid of cells, each of which can be alive or dead. Each cell’s state in the next generation depends on that of its neighbors, according to the following set of rules:\nAny live cell with fewer than two live neighbours dies, as if by underpopulation. Any live cell with two or three live neighbours lives on to the next generation. Any live cell with more than three live neighbours dies, as if by overpopulation. Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction. – Wikipedia\nLet’s implement this in numpy and scipy, the foundational packages in Python’s scientific computing ecosystem.\nCreating a random grid with numpy A grid of cells that can be alive (1) or dead (0) is just a matrix of binary values. Using numpy’s utilities for generating random arrays, we can create an example grid of random ones and zeroes like this:\n\u003e\u003e\u003e import numpy as np \u003e\u003e\u003e def create_random_grid(length: int = 4, width: int = 4, seed = None) -\u003e np.array: ... \"\"\"Create a random 2D binary array sampled from a uniform distribution.\"\"\" ... rng = default_rng(seed = seed) ... return rng.integers( ... low = 0, high = 2, size = length * width ... ).reshape(length, width) \u003e\u003e\u003e grid = create_random_grid() \u003e\u003e\u003e print(grid) array([[0, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1]]) In this code block, we use numpy’s default random number generator (RNG) to create an array of 16 integers in the range [0, 2) (the upper bound is excluded), which we then reshape into a 4x4 matrix. This will represent the initial conditions of Conway’s game.\nCounting neighbors with scipy’s ndimage library Next, we need a way to check the number of living neighbors of each cell. In an infinite grid, every cell has 8 neighbors: 3 above, 3 below, and one on either side. Including the central cell, that’s a 3x3 window that we’ll need to construct for every cell in the grid, counting the live cells each time. We can then set the new value of the central cell based on the sum of its neighbors. If this sounds familiar, it might be because this is the same kind of procedure you would see in a layer of a convolutional neural network, where a kernel is applied over a sliding window of an image or signal. We don’t need to install pytorch for our game though!\nInstead, we’ll use the convolve function in scipy.ndimage 1. Provided our initial grid and a kernel, convolve will perform an element-wise multiplication of the elements in the window and the kernel and then sum the result for every cell in the grid. For the mathematically inclined, the docs describe it thus,\n[Each element in the convolved array is] $C_i = \\sum_{j} I_{i+k-j}W_j$ where W is the weights kernel, j is the N-D spatial index over W, I is the input and k is the coordinate of the center of W, specified by origin in the input parameters.\n– scipy’s excellent API reference\nSince our grid is a binary matrix, convolving it with a 3x3 kernel of all ones will count the number of live cells in the window. If we change the central value of the kernel to a zero, we’ll exclude the central cell and just count the neighbors.\n\u003e\u003e\u003e from scipy import ndimage \u003e\u003e\u003e def count_neighbors(grid: np.array) -\u003e np.array: ... \"\"\"Count the live neighbors of each cell in a 2D binary array, treating off-grid neighbors as dead. Returns an np.array of the same size as the input.\"\"\" ... kernel = np.array([1,1,1,1,0,1,1,1,1]).reshape(3,3) ... return ndimage.convolve(grid, kernel, mode = 'constant', cval = 0.0) \u003e\u003e\u003e neighbors = count_neighbors(grid) \u003e\u003e\u003e print(neighbors) array([[2, 3, 3, 2], [3, 5, 7, 4], [4, 6, 6, 4], [2, 5, 4, 3]]) Here, setting the mode to constant with a cval of 0.0 instructs convolve to treat any off-grid neighbors (from cells on the edges) as 0.0 by padding the outside of the grid2.\nNow, for the rules.\nApplying the rules Rather than jump in and implement each of the 4 rules above, let’s consider the possible cases where a cell could be alive in the next generation.\nAccording to rule (2), a cell that is alive and has 2 neighbors will stay alive. Based on rules (2) and (4), any cell, alive or dead, with 3 neighbors will be alive. Factoring in rules (1) and (3), we know every other cell will die or remain dead. Taking advantage of numpy’s built-in, vectorized methods for element-wise comparisons, we can use boolean logic to implement these rules:\n\u003e\u003e\u003e def apply_conways_rules(grid: np.array) -\u003e np.array: ... \"\"\"Provided a 2D array of neighbor counts, return the next generation of living cells.\"\"\" ... neighbors = count_neighbors(grid) ... return ((neighbors == 2) \u0026 grid) | (neighbors == 3) \u003e\u003e\u003e apply_conways_rules(grid) array([[0, 1, 1, 1], [1, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 1]]) As in plain Python, 1 is “truthy” and 0 is “falsy” so we can smoothly convert between them. The \u0026 operator is equivalent to a logical and operation, and the | operator performs a logical or3. So, in effect, we check for each cell whether it has 2 neighbors and is alive or if it has exactly 3 neighbors. The logical operators return integers rather than booleans, so we get back our new grid in one line!\nCreating an infinite simulator Now, we just need a little scaffolding to repeatedly yield the next generation of the simulation.\n\u003e\u003e\u003e from typing import Generator \u003e\u003e\u003e def simulate(grid: np.array) -\u003e Generator[np.array, None, None]: ... \"\"\"Yield infinite generations of Conway's game provided a starting grid.\"\"\" ... ... while True: ... grid = apply_conways_rules(grid) ... yield grid Provided an initial grid, simulate will return a generator, which will lazily compute the next generation(s) when we ask for it. For example, we can use the islice function from the itertools package to return the state of the simulation after 5 rounds.\n\u003e\u003e\u003e import itertools as it \u003e\u003e\u003e generator = simulate(grid) \u003e\u003e\u003e next(it.islice(generator, 5, None)) array([[0, 0, 1, 1], [0, 1, 0, 1], [1, 1, 0, 1], [0, 0, 1, 1]]) Visualizing with matplotlib Lastly, let’s create a visualization of the evolving grid. We’ll need two dependencies for this: matplotlib and ffmpeg4. matplotlib provides an animation module, which we can use to create animations that we’ll save to a gif with ffmpeg5. We’ll use matplotlib.animation.FuncAnimation to create our gif6.\nThe process is as follows:\nUse islice to collect a list of matrices representing consecutive generations of the simulation Create a matplotlib.pyplot figure with plt.matshow of the initial grid Define init and update functions which will repeatedly update the data in the plot to create the animation Create the animation with matplotlib.animation.FuncAnimation Save the animation as a gif with matplotlib.animation.FFMpegWriter \u003e\u003e\u003e def save_conway_to_gif(grid: np.array, filepath: PathLike, nframes: int = 100) -\u003e None: ... \"\"\" Create a gif of the first nframes of evolution of the provided grid and save it to filepath. \"\"\" ... # create a list of arrays representing the first NFRAMES generations ... data = list(it.islice(simulate(grid), 0, nframes)) ... # create an initial matrix figure without ticks or labels ... fig = plt.figure() ... plot = plt.matshow(data[0], fignum=0, cmap = plt.get_cmap('binary')) ... plt.tick_params(left = False, right = False , labelleft = False, ... labelbottom = False, bottom = False, top = False, ... labeltop = False) ... def init(): ... \"\"\" Provides the initial plot (to be passed to FuncAnimation's init_func arg as a callable) \"\"\" ... plot.set_data(data[0]) ... return [plot] ... def update(j): ... \"\"\" Updates the figure's data in place (to be passed to the FunAnimation func arg as a callable). \"\"\" ... plot.set_data(data[j]) ... return [plot] ... metadata = dict( ... title=\"Conway's Game of Life\", artist='Will', comment='' ... ) ... writer = animation.FFMpegWriter(fps=5, metadata=metadata, bitrate=3500) ... anim = animation.FuncAnimation( ... fig, update, init_func = init, ... frames=nframes, interval = 30, blit=True ... ) ... anim.save(filepath, writer = writer, dpi = 300) If we use the create_random_grid function to select a random initial state of the simulation (where each cell has equal probability to be alive or dead), we might see something like this:\nAlready some interesting, periodic patterns!\nLastly, I took a moment to get the plaintext code for a cool, repeating pattern, the Gosper glider gun. This pattern repeatedly emits new ‘spaceships’ and cycles back to its initial state every 30 generations.\nI’m barely scratching the surface of the interesting patterns that have been discovered. If you’re interested in going down the rabbit hole, I’d recommend conwaylife.com (the homepage of the wiki is quite a trip!).\nYou can find the complete source for this post here.\nFor a purely numpy based implementation, we can use the sliding_window_view function in numpy’s stride_tricks module. First pad the grid with zeroes using np.pad, apply a 3x3 window with sliding_window_view, sum across the 2nd and 3rd axes, and subtract the original grid to exclude the central cell from each count. ↩︎\nFor image processing, we’d probably want to extend out the color at the ends (as though the same pixel color continued outside the edge of the image). The default value for the mode parameter, reflect, does exactly that. ↩︎\nIf functions are needed rather than infix operators, numpy provides logical_and and logical_or (as well as logical_not and logical_xor). ↩︎\nffmpeg the python package is a wrapper around ffmpeg the command line tool, which requires a separate installation. I installed it on my Mac with homebrew: brew install ffmpeg. ↩︎\nThe matplotlib.animation library also supports imagemagick and pillow. ↩︎\nUsing the FuncAnimation class can be a bit unwieldy, since the init_func and func must keep references to an external plot and update the data in place. Also tricky is that the class expects a sequence of plots (or artists, as the docs refers to them) at each iteration, not the updated plot as you might expect. ↩︎\n","wordCount":"1708","inLanguage":"en","datePublished":"2022-05-03T21:35:20-04:00","dateModified":"2022-05-03T21:35:20-04:00","author":{"@type":"Person","name":"Will Duke"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://willduke.github.io/posts/02-conway-with-numpy/"},"publisher":{"@type":"Organization","name":"Will Duke's Blog","logo":{"@type":"ImageObject","url":"https://willduke.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://willduke.github.io/ accesskey=h title="Will Duke's Blog (Alt + H)"><img src=https://willduke.github.io/apple-touch-icon.png alt aria-label=logo height=30>Will Duke's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://willduke.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=https://willduke.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://willduke.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://willduke.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://willduke.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://willduke.github.io/posts/>Posts</a></div><h1 class=post-title>Conway's Game of Life in Just a Few Lines with Python's Scientific Stack</h1><div class=post-meta><span title='2022-05-03 21:35:20 -0400 -0400'>May 3, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1708 words&nbsp;·&nbsp;Will Duke&nbsp;|&nbsp;<a href=https://github.com/WillDuke/willduke.github.io/tree/main/content/posts/02-conway-with-numpy.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#creating-a-random-grid-with-numpy aria-label="Creating a random grid with numpy">Creating a random grid with numpy</a></li><li><a href=#counting-neighbors-with-scipys-ndimage-library aria-label="Counting neighbors with scipy&amp;rsquo;s ndimage library">Counting neighbors with scipy&rsquo;s ndimage library</a></li><li><a href=#applying-the-rules aria-label="Applying the rules">Applying the rules</a></li><li><a href=#creating-an-infinite-simulator aria-label="Creating an infinite simulator">Creating an infinite simulator</a></li><li><a href=#visualizing-with-matplotlib aria-label="Visualizing with matplotlib">Visualizing with matplotlib</a></li></ul></div></details></div><div class=post-content><p>Awhile back, I came across a video from one of my favorite channels, <a href=https://www.youtube.com/c/numberphile>Numberphile</a>, on <a href="https://www.youtube.com/watch?v=R9Plq-D1gEk">Conway&rsquo;s Game of Life</a>. Turns out, it&rsquo;s not a game you can actually &ldquo;play,&rdquo; beyond setting the initial state of a simulation that progresses via a set of very simple rules. Devised by the British mathematician John Conway in 1970, the game is composed of a grid of cells, each of which can be alive or dead. Each cell&rsquo;s state in the next generation depends on that of its neighbors, according to the following set of rules:</p><blockquote><ol><li>Any live cell with fewer than two live neighbours dies, as if by underpopulation.</li><li>Any live cell with two or three live neighbours lives on to the next generation.</li><li>Any live cell with more than three live neighbours dies, as if by overpopulation.</li><li>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</li></ol><p>&ndash; <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life">Wikipedia</a></p></blockquote><p>Let&rsquo;s implement this in <code>numpy</code> and <code>scipy</code>, the foundational packages in Python&rsquo;s scientific computing ecosystem.</p><h2 id=creating-a-random-grid-with-numpy>Creating a random grid with numpy<a hidden class=anchor aria-hidden=true href=#creating-a-random-grid-with-numpy>#</a></h2><p>A grid of cells that can be alive (1) or dead (0) is just a matrix of binary values. Using <code>numpy</code>&rsquo;s utilities for generating random arrays, we can create an example grid of random ones and zeroes like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_random_grid</span>(length: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>, width: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>, seed <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>array:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> <span style=color:#e6db74>&#34;&#34;&#34;Create a random 2D binary array sampled from a uniform distribution.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> rng <span style=color:#f92672>=</span> default_rng(seed <span style=color:#f92672>=</span> seed)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> <span style=color:#66d9ef>return</span> rng<span style=color:#f92672>.</span>integers(
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    low <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, high <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>, size <span style=color:#f92672>=</span> length <span style=color:#f92672>*</span> width
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> )<span style=color:#f92672>.</span>reshape(length, width)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> grid <span style=color:#f92672>=</span> create_random_grid()
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(grid)
</span></span><span style=display:flex><span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>]])
</span></span></code></pre></div><p>In this code block, we use <code>numpy</code>&rsquo;s default random number generator (RNG) to create an array of 16 integers in the range [0, 2) (the upper bound is excluded), which we then <code>reshape</code> into a 4x4 matrix. This will represent the initial conditions of Conway&rsquo;s game.</p><h2 id=counting-neighbors-with-scipys-ndimage-library>Counting neighbors with scipy&rsquo;s ndimage library<a hidden class=anchor aria-hidden=true href=#counting-neighbors-with-scipys-ndimage-library>#</a></h2><p>Next, we need a way to check the number of living neighbors of each cell. In an infinite grid, every cell has 8 neighbors: 3 above, 3 below, and one on either side. Including the central cell, that&rsquo;s a 3x3 window that we&rsquo;ll need to construct for every cell in the grid, counting the live cells each time. We can then set the new value of the central cell based on the sum of its neighbors. If this sounds familiar, it might be because this is the same kind of procedure you would see in a layer of a <a href=https://en.wikipedia.org/wiki/Convolutional_neural_network>convolutional neural network</a>, where a kernel is applied over a sliding window of an image or signal. We don&rsquo;t need to install <code>pytorch</code> for our game though!</p><p>Instead, we&rsquo;ll use the <code>convolve</code> function in <code>scipy.ndimage</code> <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Provided our initial grid and a kernel, <code>convolve</code> will perform an element-wise multiplication of the elements in the window and the kernel and then sum the result for every cell in the grid. For the mathematically inclined, the docs describe it thus,</p><blockquote><p>[Each element in the convolved array is] $C_i = \sum_{j} I_{i+k-j}W_j$ where W is the <em>weights</em> kernel, j is the N-D spatial index over W, I is the <em>input</em> and k is the coordinate of the center of W, specified by <em>origin</em> in the input parameters.</p><p>&ndash; <a href=https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve>scipy&rsquo;s excellent API reference</a></p></blockquote><p>Since our grid is a binary matrix, convolving it with a 3x3 kernel of all ones will count the number of live cells in the window. If we change the central value of the kernel to a zero, we&rsquo;ll exclude the central cell and just count the neighbors.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> scipy <span style=color:#f92672>import</span> ndimage
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_neighbors</span>(grid: np<span style=color:#f92672>.</span>array) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>array:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#e6db74>&#34;&#34;&#34;Count the live neighbors of each cell in a 2D binary array,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        treating off-grid neighbors as dead. Returns an np.array of 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        the same size as the input.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     kernel <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>])<span style=color:#f92672>.</span>reshape(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#66d9ef>return</span> ndimage<span style=color:#f92672>.</span>convolve(grid, kernel, mode <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;constant&#39;</span>, cval <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> neighbors <span style=color:#f92672>=</span> count_neighbors(grid)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(neighbors)
</span></span><span style=display:flex><span>array([[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>]])
</span></span></code></pre></div><p>Here, setting the <code>mode</code> to <em>constant</em> with a <code>cval</code> of <code>0.0</code> instructs <code>convolve</code> to treat any off-grid neighbors (from cells on the edges) as <code>0.0</code> by padding the outside of the grid<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>Now, for the rules.</p><h2 id=applying-the-rules>Applying the rules<a hidden class=anchor aria-hidden=true href=#applying-the-rules>#</a></h2><p>Rather than jump in and implement each of the 4 rules above, let&rsquo;s consider the possible cases where a cell could be alive in the next generation.</p><ul><li>According to rule <strong>(2)</strong>, a cell that is alive <em>and</em> has 2 neighbors will stay alive.</li><li>Based on rules <strong>(2)</strong> and <strong>(4)</strong>, <em>any</em> cell, alive or dead, with 3 neighbors will be alive.</li><li>Factoring in rules <strong>(1)</strong> and <strong>(3)</strong>, we know every other cell will die or remain dead.</li></ul><p>Taking advantage of <code>numpy</code>&rsquo;s built-in, vectorized methods for element-wise comparisons, we can use boolean logic to implement these rules:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply_conways_rules</span>(grid: np<span style=color:#f92672>.</span>array) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>array:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#e6db74>&#34;&#34;&#34;Provided a 2D array of neighbor counts, return 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        the next generation of living cells.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>   neighbors <span style=color:#f92672>=</span> count_neighbors(grid)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>   <span style=color:#66d9ef>return</span> ((neighbors <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>&amp;</span> grid) <span style=color:#f92672>|</span> (neighbors <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> apply_conways_rules(grid)
</span></span><span style=display:flex><span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]])
</span></span></code></pre></div><p>As in plain Python, <code>1</code> is &ldquo;truthy&rdquo; and <code>0</code> is &ldquo;falsy&rdquo; so we can smoothly convert between them. The <code>&</code> operator is equivalent to a logical <code>and</code> operation, and the <code>|</code> operator performs a logical <code>or</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. So, in effect, we check for each cell whether it has 2 neighbors <em>and</em> is alive <em>or</em> if it has exactly 3 neighbors. The logical operators return integers rather than booleans, so we get back our new grid in one line!</p><h2 id=creating-an-infinite-simulator>Creating an infinite simulator<a hidden class=anchor aria-hidden=true href=#creating-an-infinite-simulator>#</a></h2><p>Now, we just need a little scaffolding to repeatedly <code>yield</code> the next generation of the simulation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Generator
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>simulate</span>(grid: np<span style=color:#f92672>.</span>array) <span style=color:#f92672>-&gt;</span> Generator[np<span style=color:#f92672>.</span>array, <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>]:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> <span style=color:#e6db74>&#34;&#34;&#34;Yield infinite generations of Conway&#39;s game
</span></span></span><span style=display:flex><span><span style=color:#e6db74>       provided a starting grid.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     grid <span style=color:#f92672>=</span> apply_conways_rules(grid)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#66d9ef>yield</span> grid
</span></span></code></pre></div><p>Provided an initial grid, <code>simulate</code> will return a <em>generator</em>, which will lazily compute the next generation(s) when we ask for it. For example, we can use the <code>islice</code> function from the <code>itertools</code> package to return the state of the simulation after 5 rounds.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> itertools <span style=color:#66d9ef>as</span> it
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> generator <span style=color:#f92672>=</span> simulate(grid)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> next(it<span style=color:#f92672>.</span>islice(generator, <span style=color:#ae81ff>5</span>, <span style=color:#66d9ef>None</span>))
</span></span><span style=display:flex><span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>]])
</span></span></code></pre></div><h2 id=visualizing-with-matplotlib>Visualizing with matplotlib<a hidden class=anchor aria-hidden=true href=#visualizing-with-matplotlib>#</a></h2><p>Lastly, let&rsquo;s create a visualization of the evolving grid. We&rsquo;ll need two dependencies for this: <code>matplotlib</code> and <code>ffmpeg</code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. <code>matplotlib</code> provides an <code>animation</code> module, which we can use to create animations that we&rsquo;ll save to a gif with <code>ffmpeg</code><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>. We&rsquo;ll use <code>matplotlib.animation.FuncAnimation</code> to create our gif<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>.</p><p>The process is as follows:</p><ul><li>Use <code>islice</code> to collect a list of matrices representing consecutive generations of the simulation</li><li>Create a <code>matplotlib.pyplot</code> figure with <code>plt.matshow</code> of the initial grid</li><li>Define <code>init</code> and <code>update</code> functions which will repeatedly update the data in the plot to create the animation</li><li>Create the animation with <code>matplotlib.animation.FuncAnimation</code></li><li>Save the animation as a gif with <code>matplotlib.animation.FFMpegWriter</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>save_conway_to_gif</span>(grid: np<span style=color:#f92672>.</span>array, filepath: PathLike, nframes: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>       Create a gif of the first nframes of 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>       evolution of the provided grid and save it to filepath.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>       &#34;&#34;&#34;</span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    <span style=color:#75715e># create a list of arrays representing the first NFRAMES generations</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    data <span style=color:#f92672>=</span> list(it<span style=color:#f92672>.</span>islice(simulate(grid), <span style=color:#ae81ff>0</span>, nframes))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    <span style=color:#75715e># create an initial matrix figure without ticks or labels</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    fig <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>figure()
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    plot <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>matshow(data[<span style=color:#ae81ff>0</span>], fignum<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, cmap <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>get_cmap(<span style=color:#e6db74>&#39;binary&#39;</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    plt<span style=color:#f92672>.</span>tick_params(left <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>, right <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span> , labelleft <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>                    labelbottom <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>, bottom <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>, top <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>, 
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>                    labeltop <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>init</span>():
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           Provides the initial plot 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           (to be passed to FuncAnimation&#39;s init_func arg as a callable)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        plot<span style=color:#f92672>.</span>set_data(data[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        <span style=color:#66d9ef>return</span> [plot]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update</span>(j):
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           Updates the figure&#39;s data in place 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           (to be passed to the FunAnimation func arg as a callable).
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        plot<span style=color:#f92672>.</span>set_data(data[j])
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        <span style=color:#66d9ef>return</span> [plot]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    metadata <span style=color:#f92672>=</span> dict(
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>       title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Conway&#39;s Game of Life&#34;</span>, artist<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Will&#39;</span>, comment<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> )
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    writer <span style=color:#f92672>=</span> animation<span style=color:#f92672>.</span>FFMpegWriter(fps<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>, metadata<span style=color:#f92672>=</span>metadata, bitrate<span style=color:#f92672>=</span><span style=color:#ae81ff>3500</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    anim <span style=color:#f92672>=</span> animation<span style=color:#f92672>.</span>FuncAnimation(
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        fig, update, init_func <span style=color:#f92672>=</span> init, 
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        frames<span style=color:#f92672>=</span>nframes, interval <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>, blit<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    )
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    anim<span style=color:#f92672>.</span>save(filepath, writer <span style=color:#f92672>=</span> writer, dpi <span style=color:#f92672>=</span> <span style=color:#ae81ff>300</span>)
</span></span></code></pre></div><p>If we use the <code>create_random_grid</code> function to select a random initial state of the simulation (where each cell has equal probability to be alive or dead), we might see something like this:</p><p><img loading=lazy src=/images/random.gif alt="&amp;ldquo;Random Start&amp;rdquo;"></p><p>Already some interesting, periodic patterns!</p><p>Lastly, I took a moment to get <a href=https://conwaylife.com/patterns/gosperglidergun.cells>the plaintext code</a> for a cool, repeating pattern, the <em>Gosper glider gun</em>. This pattern repeatedly emits new &lsquo;spaceships&rsquo; and cycles back to its initial state every 30 generations.</p><p><img loading=lazy src=/images/glider.gif alt="&amp;ldquo;Glider Gun&amp;rdquo;"></p><p>I&rsquo;m barely scratching the surface of the interesting patterns that have been discovered. If you&rsquo;re interested in going down the rabbit hole, I&rsquo;d recommend <a href=conwaylife.com>conwaylife.com</a> (the homepage of the wiki is quite a trip!).</p><p>You can find the complete source for this post <a href=https://github.com/WillDuke/blog-post-code/blob/master/blog_post_code/game_of_life/conway.py>here</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>For a purely <code>numpy</code> based implementation, we can use the <code>sliding_window_view</code> function in <code>numpy</code>&rsquo;s <code>stride_tricks</code> module. First pad the grid with zeroes using <code>np.pad</code>, apply a 3x3 window with <code>sliding_window_view</code>, sum across the 2nd and 3rd axes, and subtract the original grid to exclude the central cell from each count.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>For image processing, we&rsquo;d probably want to extend out the color at the ends (as though the same pixel color continued outside the edge of the image). The default value for the <code>mode</code> parameter, <em>reflect</em>, does exactly that.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>If functions are needed rather than <em>infix</em> operators, numpy provides <code>logical_and</code> and <code>logical_or</code> (as well as <code>logical_not</code> and <code>logical_xor</code>).&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><code>ffmpeg</code> the python package is a wrapper around <code>ffmpeg</code> the command line tool, which requires a separate installation. I installed it on my Mac with homebrew: <code>brew install ffmpeg</code>.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>The <code>matplotlib.animation</code> library also supports <code>imagemagick</code> and <code>pillow</code>.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>Using the <code>FuncAnimation</code> class can be a bit unwieldy, since the <code>init_func</code> and <code>func</code> must keep references to an external plot and update the data in place. Also tricky is that the class expects a sequence of plots (or artists, as the docs refers to them) at each iteration, not the updated plot as you might expect.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://willduke.github.io/tags/python/>python</a></li><li><a href=https://willduke.github.io/tags/scipy/>scipy</a></li><li><a href=https://willduke.github.io/tags/numpy/>numpy</a></li><li><a href=https://willduke.github.io/tags/matplotlib/>matplotlib</a></li><li><a href=https://willduke.github.io/tags/conway/>conway</a></li></ul><nav class=paginav><a class=prev href=https://willduke.github.io/posts/03-notebooks/><span class=title>« Prev</span><br><span>The Trouble with Notebooks</span></a>
<a class=next href=https://willduke.github.io/posts/01-my-first-post/><span class=title>Next »</span><br><span>My First Post</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Conway's Game of Life in Just a Few Lines with Python's Scientific Stack on twitter" href="https://twitter.com/intent/tweet/?text=Conway%27s%20Game%20of%20Life%20in%20Just%20a%20Few%20Lines%20with%20Python%27s%20Scientific%20Stack&url=https%3a%2f%2fwillduke.github.io%2fposts%2f02-conway-with-numpy%2f&hashtags=python%2cscipy%2cnumpy%2cmatplotlib%2cconway"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Conway's Game of Life in Just a Few Lines with Python's Scientific Stack on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwillduke.github.io%2fposts%2f02-conway-with-numpy%2f&title=Conway%27s%20Game%20of%20Life%20in%20Just%20a%20Few%20Lines%20with%20Python%27s%20Scientific%20Stack&summary=Conway%27s%20Game%20of%20Life%20in%20Just%20a%20Few%20Lines%20with%20Python%27s%20Scientific%20Stack&source=https%3a%2f%2fwillduke.github.io%2fposts%2f02-conway-with-numpy%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Conway's Game of Life in Just a Few Lines with Python's Scientific Stack on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwillduke.github.io%2fposts%2f02-conway-with-numpy%2f&title=Conway%27s%20Game%20of%20Life%20in%20Just%20a%20Few%20Lines%20with%20Python%27s%20Scientific%20Stack"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Conway's Game of Life in Just a Few Lines with Python's Scientific Stack on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwillduke.github.io%2fposts%2f02-conway-with-numpy%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Conway's Game of Life in Just a Few Lines with Python's Scientific Stack on whatsapp" href="https://api.whatsapp.com/send?text=Conway%27s%20Game%20of%20Life%20in%20Just%20a%20Few%20Lines%20with%20Python%27s%20Scientific%20Stack%20-%20https%3a%2f%2fwillduke.github.io%2fposts%2f02-conway-with-numpy%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Conway's Game of Life in Just a Few Lines with Python's Scientific Stack on telegram" href="https://telegram.me/share/url?text=Conway%27s%20Game%20of%20Life%20in%20Just%20a%20Few%20Lines%20with%20Python%27s%20Scientific%20Stack&url=https%3a%2f%2fwillduke.github.io%2fposts%2f02-conway-with-numpy%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://willduke-github-io.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2022 <a href=https://willduke.github.io/>Will Duke's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>