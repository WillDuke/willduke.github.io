<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.101.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Conway's Game of Life in Just a Few Lines with Python's Scientific Stack &#183; Will Duke's Blog</title><meta name=description content><link type=text/css rel=stylesheet href=https://willduke.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://willduke.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://willduke.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://willduke.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://willduke.github.io/><h1>Will Duke's Blog</h1></a><p class=lead>Articles & thoughts on Python, data science, etc.</p></div><nav><ul class=sidebar-nav><li><a href=https://willduke.github.io/>Home</a></li><li><a href=https://github.com/willduke/>Github</a></li><li><a href=https://www.linkedin.com/in/will-duke-86b41786/>LinkedIn</a></li></ul></nav><p>&copy; 2022. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Conway's Game of Life in Just a Few Lines with Python's Scientific Stack</h1><time datetime=2022-05-03T21:35:20-0400 class=post-date>Tue, May 3, 2022</time><p>Awhile back, I came across a video from one of my favorite channels, <a href=https://www.youtube.com/c/numberphile>Numberphile</a>, on <a href="https://www.youtube.com/watch?v=R9Plq-D1gEk">Conway&rsquo;s Game of Life</a>. Turns out, it&rsquo;s not a game you can actually &ldquo;play,&rdquo; beyond setting the initial state of a simulation that progresses via a set of very simple rules. Devised by the British mathematician John Conway in 1970, the game is composed of a grid of cells, each of which can be alive or dead. Each cell&rsquo;s state in the next generation depends on that of its neighbors, according to the following set of rules:</p><blockquote><ol><li>Any live cell with fewer than two live neighbours dies, as if by underpopulation.</li><li>Any live cell with two or three live neighbours lives on to the next generation.</li><li>Any live cell with more than three live neighbours dies, as if by overpopulation.</li><li>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</li></ol><p>&ndash; <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life">Wikipedia</a></p></blockquote><p>Let&rsquo;s implement this in <code>numpy</code> and <code>scipy</code>, the foundational packages in Python&rsquo;s scientific computing ecosystem.</p><h2 id=creating-a-random-grid-with-numpy>Creating a random grid with numpy</h2><p>A grid of cells that can be alive (1) or dead (0) is just a matrix of binary values. Using <code>numpy</code>&rsquo;s utilities for generating random arrays, we can create an example grid of random ones and zeroes like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_random_grid</span>(length: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>, width: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>, seed <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>array:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> <span style=color:#e6db74>&#34;&#34;&#34;Create a random 2D binary array sampled from a uniform distribution.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> rng <span style=color:#f92672>=</span> default_rng(seed <span style=color:#f92672>=</span> seed)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> <span style=color:#66d9ef>return</span> rng<span style=color:#f92672>.</span>integers(
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    low <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, high <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>, size <span style=color:#f92672>=</span> length <span style=color:#f92672>*</span> width
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> )<span style=color:#f92672>.</span>reshape(length, width)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> grid <span style=color:#f92672>=</span> create_random_grid()
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(grid)
</span></span><span style=display:flex><span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>]])
</span></span></code></pre></div><p>In this code block, we use <code>numpy</code>&rsquo;s default random number generator (RNG) to create an array of 16 integers in the range [0, 2) (the upper bound is excluded), which we then <code>reshape</code> into a 4x4 matrix. This will represent the initial conditions of Conway&rsquo;s game.</p><h2 id=counting-neighbors-with-scipys-ndimage-library>Counting neighbors with scipy&rsquo;s ndimage library</h2><p>Next, we need a way to check the number of living neighbors of each cell. In an infinite grid, every cell has 8 neighbors: 3 above, 3 below, and one on either side. Including the central cell, that&rsquo;s a 3x3 window that we&rsquo;ll need to construct for every cell in the grid, counting the live cells each time. We can then set the new value of the central cell based on the sum of its neighbors. If this sounds familiar, it might be because this is the same kind of procedure you would see in a layer of a <a href=https://en.wikipedia.org/wiki/Convolutional_neural_network>convolutional neural network</a>, where a kernel is applied over a sliding window of an image or signal. We don&rsquo;t need to install <code>pytorch</code> for our game though!</p><p>Instead, we&rsquo;ll use the <code>convolve</code> function in <code>scipy.ndimage</code> <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Provided our initial grid and a kernel, <code>convolve</code> will perform an element-wise multiplication of the elements in the window and the kernel and then sum the result for every cell in the grid. For the mathematically inclined, the docs describe it thus,</p><blockquote><p>[Each element in the convolved array is] $C_i = \sum_{j} I_{i+k-j}W_j$ where W is the <em>weights</em> kernel, j is the N-D spatial index over W, I is the <em>input</em> and k is the coordinate of the center of W, specified by <em>origin</em> in the input parameters.</p><p>&ndash; <a href=https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve>scipy&rsquo;s excellent API reference</a></p></blockquote><p>Since our grid is a binary matrix, convolving it with a 3x3 kernel of all ones will count the number of live cells in the window. If we change the central value of the kernel to a zero, we&rsquo;ll exclude the central cell and just count the neighbors.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> scipy <span style=color:#f92672>import</span> ndimage
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_neighbors</span>(grid: np<span style=color:#f92672>.</span>array) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>array:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#e6db74>&#34;&#34;&#34;Count the live neighbors of each cell in a 2D binary array,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        treating off-grid neighbors as dead. Returns an np.array of 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        the same size as the input.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     kernel <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>])<span style=color:#f92672>.</span>reshape(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#66d9ef>return</span> ndimage<span style=color:#f92672>.</span>convolve(grid, kernel, mode <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;constant&#39;</span>, cval <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> neighbors <span style=color:#f92672>=</span> count_neighbors(grid)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(neighbors)
</span></span><span style=display:flex><span>array([[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>]])
</span></span></code></pre></div><p>Here, setting the <code>mode</code> to <em>constant</em> with a <code>cval</code> of <code>0.0</code> instructs <code>convolve</code> to treat any off-grid neighbors (from cells on the edges) as <code>0.0</code> by padding the outside of the grid<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>Now, for the rules.</p><h2 id=applying-the-rules>Applying the rules</h2><p>Rather than jump in and implement each of the 4 rules above, let&rsquo;s consider the possible cases where a cell could be alive in the next generation.</p><ul><li>According to rule <strong>(2)</strong>, a cell that is alive <em>and</em> has 2 neighbors will stay alive.</li><li>Based on rules <strong>(2)</strong> and <strong>(4)</strong>, <em>any</em> cell, alive or dead, with 3 neighbors will be alive.</li><li>Factoring in rules <strong>(1)</strong> and <strong>(3)</strong>, we know every other cell will die or remain dead.</li></ul><p>Taking advantage of <code>numpy</code>&rsquo;s built-in, vectorized methods for element-wise comparisons, we can use boolean logic to implement these rules:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply_conways_rules</span>(grid: np<span style=color:#f92672>.</span>array) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>array:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#e6db74>&#34;&#34;&#34;Provided a 2D array of neighbor counts, return 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        the next generation of living cells.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>   neighbors <span style=color:#f92672>=</span> count_neighbors(grid)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>   <span style=color:#66d9ef>return</span> ((neighbors <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>&amp;</span> grid) <span style=color:#f92672>|</span> (neighbors <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> apply_conways_rules(grid)
</span></span><span style=display:flex><span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]])
</span></span></code></pre></div><p>As in plain Python, <code>1</code> is &ldquo;truthy&rdquo; and <code>0</code> is &ldquo;falsy&rdquo; so we can smoothly convert between them. The <code>&</code> operator is equivalent to a logical <code>and</code> operation, and the <code>|</code> operator performs a logical <code>or</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. So, in effect, we check for each cell whether it has 2 neighbors <em>and</em> is alive <em>or</em> if it has exactly 3 neighbors. The logical operators return integers rather than booleans, so we get back our new grid in one line!</p><h2 id=creating-an-infinite-simulator>Creating an infinite simulator</h2><p>Now, we just need a little scaffolding to repeatedly <code>yield</code> the next generation of the simulation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Generator
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>simulate</span>(grid: np<span style=color:#f92672>.</span>array) <span style=color:#f92672>-&gt;</span> Generator[np<span style=color:#f92672>.</span>array, <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>]:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> <span style=color:#e6db74>&#34;&#34;&#34;Yield infinite generations of Conway&#39;s game
</span></span></span><span style=display:flex><span><span style=color:#e6db74>       provided a starting grid.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     grid <span style=color:#f92672>=</span> apply_conways_rules(grid)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>     <span style=color:#66d9ef>yield</span> grid
</span></span></code></pre></div><p>Provided an initial grid, <code>simulate</code> will return a <em>generator</em>, which will lazily compute the next generation(s) when we ask for it. For example, we can use the <code>islice</code> function from the <code>itertools</code> package to return the state of the simulation after 5 rounds.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> itertools <span style=color:#66d9ef>as</span> it
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> generator <span style=color:#f92672>=</span> simulate(grid)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> next(it<span style=color:#f92672>.</span>islice(generator, <span style=color:#ae81ff>5</span>, <span style=color:#66d9ef>None</span>))
</span></span><span style=display:flex><span>array([[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>       [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>]])
</span></span></code></pre></div><h2 id=visualizing-with-matplotlib>Visualizing with matplotlib</h2><p>Lastly, let&rsquo;s create a visualization of the evolving grid. We&rsquo;ll need two dependencies for this: <code>matplotlib</code> and <code>ffmpeg</code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. <code>matplotlib</code> provides an <code>animation</code> module, which we can use to create animations that we&rsquo;ll save to a gif with <code>ffmpeg</code><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>. We&rsquo;ll use <code>matplotlib.animation.FuncAnimation</code> to create our gif<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>.</p><p>The process is as follows:</p><ul><li>Use <code>islice</code> to collect a list of matrices representing consecutive generations of the simulation</li><li>Create a <code>matplotlib.pyplot</code> figure with <code>plt.matshow</code> of the initial grid</li><li>Define <code>init</code> and <code>update</code> functions which will repeatedly update the data in the plot to create the animation</li><li>Create the animation with <code>matplotlib.animation.FuncAnimation</code></li><li>Save the animation as a gif with <code>matplotlib.animation.FFMpegWriter</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>save_conway_to_gif</span>(grid: np<span style=color:#f92672>.</span>array, filepath: PathLike, nframes: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>       Create a gif of the first nframes of 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>       evolution of the provided grid and save it to filepath.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>       &#34;&#34;&#34;</span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    <span style=color:#75715e># create a list of arrays representing the first NFRAMES generations</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    data <span style=color:#f92672>=</span> list(it<span style=color:#f92672>.</span>islice(simulate(grid), <span style=color:#ae81ff>0</span>, nframes))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    <span style=color:#75715e># create an initial matrix figure without ticks or labels</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    fig <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>figure()
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    plot <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>matshow(data[<span style=color:#ae81ff>0</span>], fignum<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, cmap <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>get_cmap(<span style=color:#e6db74>&#39;binary&#39;</span>))
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    plt<span style=color:#f92672>.</span>tick_params(left <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>, right <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span> , labelleft <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>                    labelbottom <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>, bottom <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>, top <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>, 
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>                    labeltop <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>init</span>():
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           Provides the initial plot 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           (to be passed to FuncAnimation&#39;s init_func arg as a callable)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        plot<span style=color:#f92672>.</span>set_data(data[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        <span style=color:#66d9ef>return</span> [plot]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update</span>(j):
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           Updates the figure&#39;s data in place 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           (to be passed to the FunAnimation func arg as a callable).
</span></span></span><span style=display:flex><span><span style=color:#e6db74>           &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        plot<span style=color:#f92672>.</span>set_data(data[j])
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        <span style=color:#66d9ef>return</span> [plot]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    metadata <span style=color:#f92672>=</span> dict(
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>       title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Conway&#39;s Game of Life&#34;</span>, artist<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Will&#39;</span>, comment<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> )
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    writer <span style=color:#f92672>=</span> animation<span style=color:#f92672>.</span>FFMpegWriter(fps<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>, metadata<span style=color:#f92672>=</span>metadata, bitrate<span style=color:#f92672>=</span><span style=color:#ae81ff>3500</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    anim <span style=color:#f92672>=</span> animation<span style=color:#f92672>.</span>FuncAnimation(
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        fig, update, init_func <span style=color:#f92672>=</span> init, 
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>        frames<span style=color:#f92672>=</span>nframes, interval <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>, blit<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    )
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>    anim<span style=color:#f92672>.</span>save(filepath, writer <span style=color:#f92672>=</span> writer, dpi <span style=color:#f92672>=</span> <span style=color:#ae81ff>300</span>)
</span></span></code></pre></div><p>If we use the <code>create_random_grid</code> function to select a random initial state of the simulation (where each cell has equal probability to be alive or dead), we might see something like this:</p><p><img src=/images/random.gif alt="&amp;ldquo;Random Start&amp;rdquo;"></p><p>Already some interesting, periodic patterns!</p><p>Lastly, I took a moment to get <a href=https://conwaylife.com/patterns/gosperglidergun.cells>the plaintext code</a> for a cool, repeating pattern, the <em>Gosper glider gun</em>. This pattern repeatedly emits new &lsquo;spaceships&rsquo; and cycles back to its initial state every 30 generations.</p><p><img src=/images/glider.gif alt="&amp;ldquo;Glider Gun&amp;rdquo;"></p><p>I&rsquo;m barely scratching the surface of the interesting patterns that have been discovered. If you&rsquo;re interested in going down the rabbit hole, I&rsquo;d recommend <a href=conwaylife.com>conwaylife.com</a> (the homepage of the wiki is quite a trip!).</p><p>You can find the complete source for this post <a href=https://github.com/WillDuke/blog-post-code/blob/master/blog_post_code/game_of_life/conway.py>here</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>For a purely <code>numpy</code> based implementation, we can use the <code>sliding_window_view</code> function in <code>numpy</code>&rsquo;s <code>stride_tricks</code> module. First pad the grid with zeroes using <code>np.pad</code>, apply a 3x3 window with <code>sliding_window_view</code>, sum across the 2nd and 3rd axes, and subtract the original grid to exclude the central cell from each count.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>For image processing, we&rsquo;d probably want to extend out the color at the ends (as though the same pixel color continued outside the edge of the image). The default value for the <code>mode</code> parameter, <em>reflect</em>, does exactly that.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>If functions are needed rather than <em>infix</em> operators, numpy provides <code>logical_and</code> and <code>logical_or</code> (as well as <code>logical_not</code> and <code>logical_xor</code>).&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><code>ffmpeg</code> the python package is a wrapper around <code>ffmpeg</code> the command line tool, which requires a separate installation. I installed it on my Mac with homebrew: <code>brew install ffmpeg</code>.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>The <code>matplotlib.animation</code> library also supports <code>imagemagick</code> and <code>pillow</code>.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>Using the <code>FuncAnimation</code> class can be a bit unwieldy, since the <code>init_func</code> and <code>func</code> must keep references to an external plot and update the data in place. Also tricky is that the class expects a sequence of plots (or artists, as the docs refers to them) at each iteration, not the updated plot as you might expect.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></main></body></html>