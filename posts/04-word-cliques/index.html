<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Solving Matt Parker's Wordle Puzzle in Seconds with iGraph | Will Duke's Blog</title><meta name=keywords content="python,igraph,wordle,functional"><meta name=description content="A few weeks ago, Matt Parker released a video where he posed a question he&rsquo;d received from a viewer about the popular game Wordle: how many words can you try in a Wordle game without reusing a letter? At most, the answer can be 5 (25 letters total with one unused). So the question becomes: are there sets of five English words without any overlapping letters, and (while we&rsquo;re at it) if so, how many?"><meta name=author content="Will Duke"><link rel=canonical href=https://willduke.github.io/posts/04-word-cliques/><meta name=google-site-verification content="G-DW1P8KG3ES"><link crossorigin=anonymous href=/assets/css/stylesheet.53d97598899667e064f3ce6a3016e01bf8d751bc9fa264a5e95bbdcbee247dfa.css integrity="sha256-U9l1mImWZ+Bk885qMBbgG/jXUbyfomSl6Vu9y+4kffo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://willduke.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://willduke.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://willduke.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://willduke.github.io/apple-touch-icon.png><link rel=mask-icon href=https://willduke.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Solving Matt Parker's Wordle Puzzle in Seconds with iGraph"><meta property="og:description" content="A few weeks ago, Matt Parker released a video where he posed a question he&rsquo;d received from a viewer about the popular game Wordle: how many words can you try in a Wordle game without reusing a letter? At most, the answer can be 5 (25 letters total with one unused). So the question becomes: are there sets of five English words without any overlapping letters, and (while we&rsquo;re at it) if so, how many?"><meta property="og:type" content="article"><meta property="og:url" content="https://willduke.github.io/posts/04-word-cliques/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-03T13:42:33-04:00"><meta property="article:modified_time" content="2022-09-03T13:42:33-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Solving Matt Parker's Wordle Puzzle in Seconds with iGraph"><meta name=twitter:description content="A few weeks ago, Matt Parker released a video where he posed a question he&rsquo;d received from a viewer about the popular game Wordle: how many words can you try in a Wordle game without reusing a letter? At most, the answer can be 5 (25 letters total with one unused). So the question becomes: are there sets of five English words without any overlapping letters, and (while we&rsquo;re at it) if so, how many?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://willduke.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Solving Matt Parker's Wordle Puzzle in Seconds with iGraph","item":"https://willduke.github.io/posts/04-word-cliques/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Solving Matt Parker's Wordle Puzzle in Seconds with iGraph","name":"Solving Matt Parker\u0027s Wordle Puzzle in Seconds with iGraph","description":"A few weeks ago, Matt Parker released a video where he posed a question he\u0026rsquo;d received from a viewer about the popular game Wordle: how many words can you try in a Wordle game without reusing a letter? At most, the answer can be 5 (25 letters total with one unused). So the question becomes: are there sets of five English words without any overlapping letters, and (while we\u0026rsquo;re at it) if so, how many?","keywords":["python","igraph","wordle","functional"],"articleBody":"A few weeks ago, Matt Parker released a video where he posed a question he’d received from a viewer about the popular game Wordle: how many words can you try in a Wordle game without reusing a letter? At most, the answer can be 5 (25 letters total with one unused). So the question becomes: are there sets of five English words without any overlapping letters, and (while we’re at it) if so, how many?\nTo answer this, Parker used a relatively naive approach that took about a month to run on an extra laptop. Quite a few clever people have since optimized their solutions to run much faster. In particular, Parker provided a link to Benjamin Paasen’s method, which used graph theory to bring the running time down to just over 20 minutes.\nEssentially, the problem of finding sets of non-overlapping words can be reframed as finding a fully-connected subgraph in a network where all nodes are words and edges connect words which share no letters. By fully-connected, I mean that every node (word) has an edge (i.e. shares no letters) with every other word in that part of the network. In graph theory, these groups are known as cliques and there are a number of algorithms for finding them.\nPassen implemented a method that builds cliques by searching neighbors for intersections of progressively more words. I thought we’d give the same approach a try, but see if we can take advantage of Python’s fantastic ecosystem – namely, the igraph package – to further improve the speed. First, we’ll need to recreate the set of words from which to search for five-word cliques. I used Parker’s source for all English words: the words_alpha.zip file which can be found here.\nPreparing the Word List in (Functional) Style After downloading the zip archive, we can load the words as an iterable using the zipfile library:\nimport zipfile from pathlib import Path from typing import Dict, Iterable, List, Tuple def extract_archive_to_word_list( archive_path: Path, filename: str ) -\u003e Iterable[str]: \"\"\" Provided a path to a zip archive and the name of the file within the archive containing an english word list, extract and read the file and return an iterable of the words. \"\"\" return ( zipfile.ZipFile(archive_path, 'r') .read(filename) .decode('utf-8') .split(\"\\r\\n\") ) Now, we have a series of filtering operations to do to select only 5 letter words without duplicate letters and to keep only one word from word sets which contain the same letters. I’ll use the pipe package to make each function work with shell-style piping to avoid creating intermediate variables.\nfrom pipe import Pipe @Pipe def filter_words_of_length_n(words: List[str], n: int) -\u003e Iterable[str]: \"\"\"Filter out words not of length n.\"\"\" return filter(lambda word: len(word) == n, words) @Pipe def filter_words_with_duplicate_letters(words) -\u003e Iterable[str]: \"Filter out words with more than one of any letter.\" return filter(lambda word: len(word) == len(set(word)), words) @Pipe def filter_duplicate_word_sets(words: Iterable[str]) -\u003e Iterable[str]: \"\"\"Filter out words with the same set of letters as an already seen word.\"\"\" seen = set() seen_add = seen.add for word in words: wordset = frozenset(word) if wordset not in seen: seen_add(wordset) yield word By filtering our word list with each of these functions, we can keep only words of length 5 which have no duplicate letters and remove any words that share all letters with words previously seen in the list. (For example, “create” and “react” share the same letters, so we’ll just choose one to include since the other will share all of the same cliques.) Thanks to the @Pipe decoration, each of these operations can be chained together with the | operator (which calls the next function on the result of the previous one):\n@Pipe def get_unique_set_words_of_length_n( words: Iterable[str], n: int ) -\u003e Iterable[str]: \"\"\"Get the filtered list of words of length n with no repeating digits, omitting any words with duplicate letter sets.\"\"\" return ( words | filter_words_of_length_n(n) | filter_words_with_duplicate_letters | filter_duplicate_word_sets ) Note that the @Pipe decorator curries filter_words_of_length_n so that it can be called once for each of its arguments. The first argument is presumed to be the iterable, so calling the function with n=5 returns a partial function with the n parameter pre-filled.\nOk, with that done, we can move on to creating our graph.\nBuilding a Graph with iGraph The igraph package provides a powerful Python interface to its optimized-C core graph routines, which we can use to find our 5-cliques. Creating an igraph.Graph object requires a list of all of the edges in the graph identified by tuples of vertex indices. (The constructor will infer the nodes from this list.)\nimport itertools as it from igraph import Graph def create_graph_of_disjoint_words(words: Iterable[str]) -\u003e Graph: \"\"\" Create a igraph.Graph where each vertex is a word and two words share an edge if they have no letters in common. igraph.Graph takes a list of edges as tuples of vertex indices. The edges are created by iterating through each word and adding edges for any remaining words that have disjoint letter sets. \"\"\" wordsets = list(map(set, words)) edges = [ (i, j) for i, left in enumerate(wordsets) for j, right in it.islice(enumerate(wordsets), i+1, None) if left.isdisjoint(right) ] return Graph(edges = edges) To create our list of vertices, we iterate through each of the words and add a tuple of node IDs (indices corresponding to the each word’s position in the word list) where the letter sets of the two words are disjoint (i.e. they don’t share any letters). Starting from the beginning of the word list, we check only the remaining words in the list for disjoint pairs each time to avoid rechecking the pairs of words (in reverse order).\nPassing this edge list to igraph.Graph instantiates a graph with a node for each of the words in our word list with edges between words with disjoint sets of letters.\nFinding all the Cliques igraph.Graph has a cliques() method which will return cliques between a minimum and maximum size. Under the hood, this method calls the C method igraph_cliques(), which makes use of the Cliquer library written largely by Patric Östergård.1 For our purposes, finding cliques of a certain size is as simple as specifying the same lower and upper bound:\ndef find_all_size_n_cliques( words: Iterable[str], size: int ) -\u003e Iterable[Dict[int, Tuple[str, ...]]]: \"\"\"Provided an iterable of strings, return all of the sets of words of a given size with no overlapping letters between any pair in the set.\"\"\" _words = list(words) graph = create_graph_of_disjoint_words(_words) for pos, clique in enumerate(graph.cliques(size, size)): yield {pos: tuple(_words[idx] for idx in clique)} Note: Here, we call list() on the words iterable since we’ll need it multiple times. (Otherwise, the iterable may be exhausted if it is a generator.)\nI like using jsonlines as a serialization format, so I’ve formatted each set of words as a dictionary with the clique index as the key and the tuple of words as the values. (The cliques algorithm returns the node indices, so we have to recover the original words).\nLastly, we can write can create a main function that will write the results of this search to a jsonl file.\nPARENT_DIR = Path(__file__).parent WORDS_ARCHIVE_PATH = PARENT_DIR / \"words_alpha.zip\" WORDS_FILENAME = \"words_alpha.txt\" CLIQUES_PATH = PARENT_DIR / \"cliques.jsonl\" def main( words_archive_path: Path = WORDS_ARCHIVE_PATH, words_filename: str = WORDS_FILENAME, cliques_path: Path = CLIQUES_PATH ): \"\"\" Load a list of words from a file (filename: word_filename) within a zip archive (words_archive_path). Save a file with all of the cliques (of mutually exlusive letters) to cliques_path. \"\"\" words = ( extract_archive_to_word_list(words_archive_path, words_filename) | get_unique_set_words_of_length_n(5) ) five_cliques = find_all_size_n_cliques(words, 5) with jsonlines.open(cliques_path, 'w') as writer: writer.write_all(five_cliques) if __name__ == '__main__': main() Including the time to load in the data and construct the igraph.Graph, this script took 10.2 seconds on my 2019 Macbook Pro. In total, there were 538 five-word sets using 25 letters (ignoring anagrams).\nHere’s a sampling of some of the word sets:\nchivw enzym fldxt jakob sprug ampyx crwth fdubs glink vejoz bortz chivw dunks flegm japyx Maybe I shouldn’t be surprised that these stretch the definition of English word.\nYou can find the complete source for this post here.\nThe source for the C implementation can be found here. ↩︎\n","wordCount":"1358","inLanguage":"en","datePublished":"2022-09-03T13:42:33-04:00","dateModified":"2022-09-03T13:42:33-04:00","author":{"@type":"Person","name":"Will Duke"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://willduke.github.io/posts/04-word-cliques/"},"publisher":{"@type":"Organization","name":"Will Duke's Blog","logo":{"@type":"ImageObject","url":"https://willduke.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://willduke.github.io/ accesskey=h title="Will Duke's Blog (Alt + H)"><img src=https://willduke.github.io/apple-touch-icon.png alt aria-label=logo height=30>Will Duke's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://willduke.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=https://willduke.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://willduke.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://willduke.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://willduke.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://willduke.github.io/posts/>Posts</a></div><h1 class=post-title>Solving Matt Parker's Wordle Puzzle in Seconds with iGraph</h1><div class=post-meta><span title='2022-09-03 13:42:33 -0400 -0400'>September 3, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1358 words&nbsp;·&nbsp;Will Duke&nbsp;|&nbsp;<a href=https://github.com/WillDuke/willduke.github.io/tree/main/content/posts/04-word-cliques.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#preparing-the-word-list-in-functional-style aria-label="Preparing the Word List in (Functional) Style">Preparing the Word List in (Functional) Style</a></li><li><a href=#building-a-graph-with-igraph aria-label="Building a Graph with iGraph">Building a Graph with iGraph</a></li><li><a href=#finding-all-the-cliques aria-label="Finding all the Cliques">Finding all the Cliques</a></li></ul></div></details></div><div class=post-content><p>A few weeks ago, Matt Parker released a <a href="https://www.youtube.com/watch?v=_-AfhLQfb6w">video</a> where he posed a question he&rsquo;d received from a viewer about the popular game Wordle: how many words can you try in a Wordle game without reusing a letter? At most, the answer can be 5 (25 letters total with one unused). So the question becomes: are there sets of five English words without any overlapping letters, and (while we&rsquo;re at it) if so, how many?</p><p>To answer this, Parker used a <a href=https://github.com/standupmaths/fiveletterworda>relatively naive approach</a> that took about a month to run on an extra laptop. Quite a few clever people have since optimized their solutions to run much faster. In particular, Parker provided a link to <a href=https://gitlab.com/bpaassen/five_clique>Benjamin Paasen&rsquo;s method</a>, which used graph theory to bring the running time down to just over 20 minutes.</p><p>Essentially, the problem of finding sets of non-overlapping words can be reframed as finding a fully-connected subgraph in a network where all nodes are words and edges connect words which share no letters. By fully-connected, I mean that every node (word) has an edge (i.e. shares no letters) with every other word in that part of the network. In graph theory, these groups are known as <em>cliques</em> and there are a number of algorithms for finding them.</p><figure><img loading=lazy src=/images/clique.png alt="An example 5-word clique"></figure><p>Passen implemented a method that builds cliques by searching neighbors for intersections of progressively more words. I thought we&rsquo;d give the same approach a try, but see if we can take advantage of Python&rsquo;s fantastic ecosystem &ndash; namely, the <code>igraph</code> package &ndash; to further improve the speed. First, we&rsquo;ll need to recreate the set of words from which to search for five-word cliques. I used Parker&rsquo;s source for all English words: the <code>words_alpha.zip</code> file which can be found <a href=https://github.com/dwyl/english-words/blob/master/words_alpha.zip>here</a>.</p><h2 id=preparing-the-word-list-in-functional-style>Preparing the Word List in (Functional) Style<a hidden class=anchor aria-hidden=true href=#preparing-the-word-list-in-functional-style>#</a></h2><p>After downloading the zip archive, we can load the words as an iterable using the <code>zipfile</code> library:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> zipfile
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pathlib <span style=color:#f92672>import</span> Path
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Dict, Iterable, List, Tuple
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>extract_archive_to_word_list</span>(
</span></span><span style=display:flex><span>    archive_path: Path, filename: str
</span></span><span style=display:flex><span>) <span style=color:#f92672>-&gt;</span> Iterable[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Provided a path to a zip archive and the name of the file within the 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    archive containing an english word list, extract and read the file
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    and return an iterable of the words.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>        zipfile<span style=color:#f92672>.</span>ZipFile(archive_path, <span style=color:#e6db74>&#39;r&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>read(filename)
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    )
</span></span></code></pre></div><p>Now, we have a series of filtering operations to do to select only 5 letter words without duplicate letters and to keep only one word from word sets which contain the same letters. I&rsquo;ll use the <code>pipe</code> <a href=https://github.com/JulienPalard/Pipe>package</a> to make each function work with shell-style piping to avoid creating intermediate variables.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pipe <span style=color:#f92672>import</span> Pipe
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Pipe</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>filter_words_of_length_n</span>(words: List[str], n: int) <span style=color:#f92672>-&gt;</span> Iterable[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Filter out words not of length n.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> filter(<span style=color:#66d9ef>lambda</span> word: len(word) <span style=color:#f92672>==</span> n, words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Pipe</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>filter_words_with_duplicate_letters</span>(words) <span style=color:#f92672>-&gt;</span> Iterable[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Filter out words with more than one of any letter.&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> filter(<span style=color:#66d9ef>lambda</span> word: len(word) <span style=color:#f92672>==</span> len(set(word)), words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Pipe</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>filter_duplicate_word_sets</span>(words: Iterable[str]) <span style=color:#f92672>-&gt;</span> Iterable[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Filter out words with the same set of letters as an already seen word.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    seen <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>    seen_add <span style=color:#f92672>=</span> seen<span style=color:#f92672>.</span>add
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> words:
</span></span><span style=display:flex><span>        wordset <span style=color:#f92672>=</span> frozenset(word)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> wordset <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>            seen_add(wordset)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>yield</span> word
</span></span></code></pre></div><p>By filtering our word list with each of these functions, we can keep only words of length 5 which have no duplicate letters and remove any words that share all letters with words previously seen in the list. (For example, &ldquo;create&rdquo; and &ldquo;react&rdquo; share the same letters, so we&rsquo;ll just choose one to include since the other will share all of the same cliques.) Thanks to the <code>@Pipe</code> decoration, each of these operations can be chained together with the <code>|</code> operator (which calls the next function on the result of the previous one):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@Pipe</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_unique_set_words_of_length_n</span>(
</span></span><span style=display:flex><span>    words: Iterable[str], n: int
</span></span><span style=display:flex><span>) <span style=color:#f92672>-&gt;</span> Iterable[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Get the filtered list of words of length n with no repeating digits,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    omitting any words with duplicate letter sets.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>        words
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> filter_words_of_length_n(n)
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> filter_words_with_duplicate_letters
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> filter_duplicate_word_sets
</span></span><span style=display:flex><span>    )
</span></span></code></pre></div><blockquote><p>Note that the <code>@Pipe</code> decorator <a href=https://towardsdatascience.com/what-is-currying-in-programming-56fd57103431>curries</a> <code>filter_words_of_length_n</code> so that it can be called once for each of its arguments. The first argument is presumed to be the iterable, so calling the function with <code>n=5</code> returns a partial function with the <code>n</code> parameter pre-filled.</p></blockquote><p>Ok, with that done, we can move on to creating our graph.</p><h2 id=building-a-graph-with-igraph>Building a Graph with iGraph<a hidden class=anchor aria-hidden=true href=#building-a-graph-with-igraph>#</a></h2><p>The <code>igraph</code> package provides a powerful Python interface to its optimized-C core graph routines, which we can use to find our 5-cliques. Creating an <code>igraph.Graph</code> object requires a list of all of the edges in the graph identified by tuples of vertex indices. (The constructor will infer the nodes from this list.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> itertools <span style=color:#66d9ef>as</span> it
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> igraph <span style=color:#f92672>import</span> Graph
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_graph_of_disjoint_words</span>(words: Iterable[str]) <span style=color:#f92672>-&gt;</span> Graph:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Create a igraph.Graph where each vertex is a word and two words
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    share an edge if they have no letters in common.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    igraph.Graph takes a list of edges as tuples of vertex indices.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    The edges are created by iterating through each word and adding
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    edges for any remaining words that have disjoint letter sets.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    wordsets <span style=color:#f92672>=</span> list(map(set, words))
</span></span><span style=display:flex><span>    edges <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        (i, j)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, left <span style=color:#f92672>in</span> enumerate(wordsets)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j, right <span style=color:#f92672>in</span> it<span style=color:#f92672>.</span>islice(enumerate(wordsets), i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> left<span style=color:#f92672>.</span>isdisjoint(right)
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Graph(edges <span style=color:#f92672>=</span> edges)
</span></span></code></pre></div><p>To create our list of vertices, we iterate through each of the words and add a tuple of node IDs (indices corresponding to the each word&rsquo;s position in the word list) where the letter sets of the two words are disjoint (i.e. they don&rsquo;t share any letters). Starting from the beginning of the word list, we check only the remaining words in the list for disjoint pairs each time to avoid rechecking the pairs of words (in reverse order).</p><p>Passing this edge list to <code>igraph.Graph</code> instantiates a graph with a node for each of the words in our word list with edges between words with disjoint sets of letters.</p><h2 id=finding-all-the-cliques>Finding all the Cliques<a hidden class=anchor aria-hidden=true href=#finding-all-the-cliques>#</a></h2><p><code>igraph.Graph</code> has a <code>cliques()</code> <a href=https://igraph.org/python/doc/api/igraph._igraph.GraphBase.html#cliques>method</a> which will return cliques between a minimum and maximum size. Under the hood, this method calls the <a href=https://igraph.org/c/doc/igraph-Cliques.html#cliques>C method</a> <code>igraph_cliques()</code>, which makes use of the <a href=https://users.aalto.fi/~pat/cliquer.html>Cliquer</a> library written largely by Patric Östergård.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> For our purposes, finding cliques of a certain size is as simple as specifying the same lower and upper bound:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_all_size_n_cliques</span>(
</span></span><span style=display:flex><span>    words: Iterable[str], size: int
</span></span><span style=display:flex><span>) <span style=color:#f92672>-&gt;</span> Iterable[Dict[int, Tuple[str, <span style=color:#f92672>...</span>]]]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Provided an iterable of strings, return all of the sets of words
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    of a given size with no overlapping letters between any pair in the set.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    _words <span style=color:#f92672>=</span> list(words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    graph <span style=color:#f92672>=</span> create_graph_of_disjoint_words(_words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> pos, clique <span style=color:#f92672>in</span> enumerate(graph<span style=color:#f92672>.</span>cliques(size, size)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> {pos: tuple(_words[idx] <span style=color:#66d9ef>for</span> idx <span style=color:#f92672>in</span> clique)}
</span></span></code></pre></div><blockquote><p>Note: Here, we call <code>list()</code> on the <code>words</code> iterable since we&rsquo;ll need it multiple times. (Otherwise, the iterable may be exhausted if it is a generator.)</p></blockquote><p>I like using <code>jsonlines</code> as a serialization format, so I&rsquo;ve formatted each set of words as a dictionary with the clique index as the key and the tuple of words as the values. (The cliques algorithm returns the node indices, so we have to recover the original words).</p><p>Lastly, we can write can create a <code>main</code> function that will write the results of this search to a <code>jsonl</code> file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>PARENT_DIR <span style=color:#f92672>=</span> Path(__file__)<span style=color:#f92672>.</span>parent
</span></span><span style=display:flex><span>WORDS_ARCHIVE_PATH <span style=color:#f92672>=</span> PARENT_DIR <span style=color:#f92672>/</span> <span style=color:#e6db74>&#34;words_alpha.zip&#34;</span>
</span></span><span style=display:flex><span>WORDS_FILENAME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;words_alpha.txt&#34;</span>
</span></span><span style=display:flex><span>CLIQUES_PATH <span style=color:#f92672>=</span> PARENT_DIR <span style=color:#f92672>/</span> <span style=color:#e6db74>&#34;cliques.jsonl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>(
</span></span><span style=display:flex><span>    words_archive_path: Path <span style=color:#f92672>=</span> WORDS_ARCHIVE_PATH,
</span></span><span style=display:flex><span>    words_filename: str <span style=color:#f92672>=</span> WORDS_FILENAME,
</span></span><span style=display:flex><span>    cliques_path: Path <span style=color:#f92672>=</span> CLIQUES_PATH
</span></span><span style=display:flex><span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Load a list of words from a file (filename: word_filename) 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    within a zip archive (words_archive_path). Save a file with
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    all of the cliques (of mutually exlusive letters) to cliques_path.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    words <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        extract_archive_to_word_list(words_archive_path, words_filename)
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> get_unique_set_words_of_length_n(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    five_cliques <span style=color:#f92672>=</span> find_all_size_n_cliques(words, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> jsonlines<span style=color:#f92672>.</span>open(cliques_path, <span style=color:#e6db74>&#39;w&#39;</span>) <span style=color:#66d9ef>as</span> writer:
</span></span><span style=display:flex><span>        writer<span style=color:#f92672>.</span>write_all(five_cliques)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><p>Including the time to load in the data and construct the <code>igraph.Graph</code>, this script took 10.2 seconds on my 2019 Macbook Pro. In total, there were 538 five-word sets using 25 letters (ignoring anagrams).</p><p>Here&rsquo;s a sampling of some of the word sets:</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>chivw</td><td>enzym</td><td>fldxt</td><td>jakob</td><td>sprug</td></tr><tr><td>ampyx</td><td>crwth</td><td>fdubs</td><td>glink</td><td>vejoz</td></tr><tr><td>bortz</td><td>chivw</td><td>dunks</td><td>flegm</td><td>japyx</td></tr></tbody></table><p>Maybe I shouldn&rsquo;t be surprised that these stretch the definition of English word.</p><p>You can find the complete source for this post <a href=https://github.com/WillDuke/blog-post-code/blob/master/blog_post_code/wordle_cliques/cliques.py>here</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The source for the C implementation can be found <a href=https://github.com/igraph/igraph/blob/df17b097fd9b582241ee3f38aa82e03eba05d785/src/cliques/cliquer/cliquer.c#L337>here</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://willduke.github.io/tags/python/>python</a></li><li><a href=https://willduke.github.io/tags/igraph/>igraph</a></li><li><a href=https://willduke.github.io/tags/wordle/>wordle</a></li><li><a href=https://willduke.github.io/tags/functional/>functional</a></li></ul><nav class=paginav><a class=next href=https://willduke.github.io/posts/03-notebooks/><span class=title>Next »</span><br><span>The Trouble with Notebooks</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Solving Matt Parker's Wordle Puzzle in Seconds with iGraph on twitter" href="https://twitter.com/intent/tweet/?text=Solving%20Matt%20Parker%27s%20Wordle%20Puzzle%20in%20Seconds%20with%20iGraph&url=https%3a%2f%2fwillduke.github.io%2fposts%2f04-word-cliques%2f&hashtags=python%2cigraph%2cwordle%2cfunctional"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Solving Matt Parker's Wordle Puzzle in Seconds with iGraph on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwillduke.github.io%2fposts%2f04-word-cliques%2f&title=Solving%20Matt%20Parker%27s%20Wordle%20Puzzle%20in%20Seconds%20with%20iGraph&summary=Solving%20Matt%20Parker%27s%20Wordle%20Puzzle%20in%20Seconds%20with%20iGraph&source=https%3a%2f%2fwillduke.github.io%2fposts%2f04-word-cliques%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Solving Matt Parker's Wordle Puzzle in Seconds with iGraph on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwillduke.github.io%2fposts%2f04-word-cliques%2f&title=Solving%20Matt%20Parker%27s%20Wordle%20Puzzle%20in%20Seconds%20with%20iGraph"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Solving Matt Parker's Wordle Puzzle in Seconds with iGraph on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwillduke.github.io%2fposts%2f04-word-cliques%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Solving Matt Parker's Wordle Puzzle in Seconds with iGraph on whatsapp" href="https://api.whatsapp.com/send?text=Solving%20Matt%20Parker%27s%20Wordle%20Puzzle%20in%20Seconds%20with%20iGraph%20-%20https%3a%2f%2fwillduke.github.io%2fposts%2f04-word-cliques%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Solving Matt Parker's Wordle Puzzle in Seconds with iGraph on telegram" href="https://telegram.me/share/url?text=Solving%20Matt%20Parker%27s%20Wordle%20Puzzle%20in%20Seconds%20with%20iGraph&url=https%3a%2f%2fwillduke.github.io%2fposts%2f04-word-cliques%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://willduke-github-io.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2022 <a href=https://willduke.github.io/>Will Duke's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>