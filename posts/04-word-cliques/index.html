<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.102.3"><meta name=viewport content="width=device-width,initial-scale=1"><title>Solving Matt Parker's Wordle Puzzle in Seconds with iGraph &#183; Will Duke's Blog</title><meta name=description content><link type=text/css rel=stylesheet href=https://willduke.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://willduke.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://willduke.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://willduke.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://willduke.github.io/><h1>Will Duke's Blog</h1></a><p class=lead>Articles & thoughts on Python, data science, etc.</p></div><nav><ul class=sidebar-nav><li><a href=https://willduke.github.io/>Home</a></li><li><a href=https://github.com/willduke/>Github</a></li><li><a href=https://www.linkedin.com/in/will-duke-86b41786/>LinkedIn</a></li></ul></nav><p>&copy; 2022. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Solving Matt Parker's Wordle Puzzle in Seconds with iGraph</h1><time datetime=2022-09-03T13:42:33-0400 class=post-date>Sat, Sep 3, 2022</time><p>A few weeks ago, Matt Parker released a <a href="https://www.youtube.com/watch?v=_-AfhLQfb6w">video</a> where he posed a question he&rsquo;d received from a viewer about the popular game Wordle: how many words can you try in a Wordle game without reusing a letter? At most, the answer can be 5 (25 letters total with one unused). So the question becomes: are there sets of five English words without any overlapping letters, and (while we&rsquo;re at it) if so, how many?</p><p>To answer this, Parker used a <a href=https://github.com/standupmaths/fiveletterworda>relatively naive approach</a> that took about a month to run on an extra laptop. Quite a few clever people have since optimized their solutions to run much faster. In particular, Parker provided a link to <a href=https://gitlab.com/bpaassen/five_clique>Benjamin Paasen&rsquo;s method</a>, which used graph theory to bring the running time down to just over 20 minutes.</p><p>Essentially, the problem of finding sets of non-overlapping words can be reframed as finding a fully-connected subgraph in a network where all nodes are words and edges connect words which share no letters. By fully-connected, I mean that every node (word) has an edge (i.e. shares no letters) with every other word in that part of the network. In graph theory, these groups are known as <em>cliques</em> and there are a number of algorithms for finding them.</p><p><img src=/images/clique.png alt="An example 5-word clique"></p><p>Passen implemented a method that builds cliques by searching neighbors for intersections of progressively more words. I thought we&rsquo;d give the same approach a try, but see if we can take advantage of Python&rsquo;s fantastic ecosystem &ndash; namely, the <code>igraph</code> package &ndash; to further improve the speed. First, we&rsquo;ll need to recreate the set of words from which to search for five-word cliques. I used Parker&rsquo;s source for all English words: the <code>words_alpha.zip</code> file which can be found <a href=https://github.com/dwyl/english-words/blob/master/words_alpha.zip>here</a>.</p><h2 id=preparing-the-word-list-in-functional-style>Preparing the Word List in (Functional) Style</h2><p>After downloading the zip archive, we can load the words as an iterable using the <code>zipfile</code> library:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> zipfile
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pathlib <span style=color:#f92672>import</span> Path
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Dict, Iterable, List, Tuple
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>extract_archive_to_word_list</span>(
</span></span><span style=display:flex><span>    archive_path: Path, filename: str
</span></span><span style=display:flex><span>) <span style=color:#f92672>-&gt;</span> Iterable[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Provided a path to a zip archive and the name of the file within the archive containing an english word list, extract and read the file and return an iterable of the words.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>        zipfile<span style=color:#f92672>.</span>ZipFile(archive_path, <span style=color:#e6db74>&#39;r&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>read(filename)
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    )
</span></span></code></pre></div><p>Now, we have a series of filtering operations to do to select only 5 letter words without duplicate letters and to keep only one word from word sets which contain the same letters. I&rsquo;ll use the <code>pipe</code> <a href=https://github.com/JulienPalard/Pipe>package</a> to make each function work with shell-style piping to avoid creating intermediate variables.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pipe <span style=color:#f92672>import</span> Pipe
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Pipe</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>filter_words_of_length_n</span>(words: List[str], n: int) <span style=color:#f92672>-&gt;</span> Iterable[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Filter out words not of length n.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> filter(<span style=color:#66d9ef>lambda</span> word: len(word) <span style=color:#f92672>==</span> n, words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Pipe</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>filter_words_with_duplicate_letters</span>(words) <span style=color:#f92672>-&gt;</span> Iterable[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Filter out words with more than one of any letter.&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> filter(<span style=color:#66d9ef>lambda</span> word: len(word) <span style=color:#f92672>==</span> len(set(word)), words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Pipe</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>filter_duplicate_word_sets</span>(words: Iterable[str]) <span style=color:#f92672>-&gt;</span> Iterable[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Filter out words with the same set of letters as an already seen word.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    seen <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>    seen_add <span style=color:#f92672>=</span> seen<span style=color:#f92672>.</span>add
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> words:
</span></span><span style=display:flex><span>        wordset <span style=color:#f92672>=</span> frozenset(word)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> wordset <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>            seen_add(wordset)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>yield</span> word
</span></span></code></pre></div><p>By filtering our word list with each of these functions, we can keep only words of length 5 which have no duplicate letters and remove any words that share all letters with words previously seen in the list. (For example, &ldquo;create&rdquo; and &ldquo;react&rdquo; share the same letters, so we&rsquo;ll just choose one to include since the other will share all of the same cliques.) Thanks to the <code>@Pipe</code> decoration, each of these operations can be chained together with the <code>|</code> operator (which calls the next function on the result of the previous one):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@Pipe</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_unique_set_words_of_length_n</span>(words: Iterable[str], n: int) <span style=color:#f92672>-&gt;</span> Iterable[str]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Get the filtered list of words of length n with no repeating digits,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    omitting any words with duplicate letter sets.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>        words
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> filter_words_of_length_n(n)
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> filter_words_with_duplicate_letters
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> filter_duplicate_word_sets
</span></span><span style=display:flex><span>    )
</span></span></code></pre></div><blockquote><p>Note that the <code>@Pipe</code> decorator <a href=https://towardsdatascience.com/what-is-currying-in-programming-56fd57103431>curries</a> <code>filter_words_of_length_n</code> so that it can be called once for each of its arguments. The first argument is presumed to be the iterable, so calling the function with <code>n=5</code> returns a partial function with the <code>n</code> parameter pre-filled.</p></blockquote><p>Ok, with that done, we can move on to creating our graph.</p><h2 id=building-a-graph-with-igraph>Building a Graph with iGraph</h2><p>The <code>igraph</code> package provides a powerful Python interface to its optimized-C core graph routines, which we can use to find our 5-cliques. Creating an <code>igraph.Graph</code> object requires a list of all of the edges in the graph identified by tuples of vertex indices. (The constructor will infer the nodes from this list.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> itertools <span style=color:#66d9ef>as</span> it
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> igraph <span style=color:#f92672>import</span> Graph
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_graph_of_disjoint_words</span>(words: Iterable[str]) <span style=color:#f92672>-&gt;</span> Graph:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Create a igraph.Graph where each vertex is a word and two words
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    share an edge if they have no letters in common.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    igraph.Graph takes a list of edges as tuples of vertex indices.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    The edges are created by iterating through each word and adding
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    edges for any remaining words that have disjoint letter sets.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    wordsets <span style=color:#f92672>=</span> list(map(set, words))
</span></span><span style=display:flex><span>    edges <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        (i, j)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, left <span style=color:#f92672>in</span> enumerate(wordsets)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j, right <span style=color:#f92672>in</span> it<span style=color:#f92672>.</span>islice(enumerate(wordsets), i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> left<span style=color:#f92672>.</span>isdisjoint(right)
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Graph(edges <span style=color:#f92672>=</span> edges)
</span></span></code></pre></div><p>To create our list of vertices, we iterate through each of the words and add a tuple of node IDs (indices corresponding to the each word&rsquo;s position in the word list) where the letter sets of the two words are disjoint (i.e. they don&rsquo;t share any letters). Starting from the beginning of the word list, we check only the remaining words in the list for disjoint pairs each time to avoid rechecking the pairs of words (in reverse order).</p><p>Passing this edge list to <code>igraph.Graph</code> instantiates a graph with a node for each of the words in our word list with edges between words with disjoint sets of letters.</p><h2 id=finding-all-the-cliques>Finding all the cliques</h2><p><code>igraph.Graph</code> has a <code>cliques()</code> <a href=https://igraph.org/python/doc/api/igraph._igraph.GraphBase.html#cliques>method</a> which will return cliques between a minimum and maximum size. Under the hood, this method calls the <a href=https://igraph.org/c/doc/igraph-Cliques.html#cliques>C method</a> <code>igraph_cliques()</code>, which makes use of the <a href=https://users.aalto.fi/~pat/cliquer.html>Cliquer</a> library written largely by Patric Östergård.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> For our purposes, finding cliques of a certain size is as simple as specifying the same lower and upper bound:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_all_size_n_cliques</span>(
</span></span><span style=display:flex><span>    words: Iterable[str], size: int
</span></span><span style=display:flex><span>) <span style=color:#f92672>-&gt;</span> Iterable[Dict[int, Tuple[str, <span style=color:#f92672>...</span>]]]:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Provided an iterable of strings, return all of the sets of words
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    of a given size with no overlapping letters between any pair in the set.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    _words <span style=color:#f92672>=</span> list(words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    graph <span style=color:#f92672>=</span> create_graph_of_disjoint_words(_words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> pos, clique <span style=color:#f92672>in</span> enumerate(graph<span style=color:#f92672>.</span>cliques(size, size)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> {pos: tuple(_words[idx] <span style=color:#66d9ef>for</span> idx <span style=color:#f92672>in</span> clique)}
</span></span></code></pre></div><blockquote><p>Note: Here, we call <code>list()</code> on the <code>words</code> iterable since we&rsquo;ll need it multiple times. (Otherwise, the iterable may be exhausted if it is a generator.)</p></blockquote><p>I like using <code>jsonlines</code> as a serialization format, so I&rsquo;ve formatted each set of words as a dictionary with the clique index as the key and the tuple of words as the values. (The cliques algorithm returns the node indices, so we have to recover the original words).</p><p>Lastly, we can write can create a <code>main</code> function that will write the results of this search to a <code>jsonl</code> file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>PARENT_DIR <span style=color:#f92672>=</span> Path(__file__)<span style=color:#f92672>.</span>parent
</span></span><span style=display:flex><span>WORDS_ARCHIVE_PATH <span style=color:#f92672>=</span> PARENT_DIR <span style=color:#f92672>/</span> <span style=color:#e6db74>&#34;words_alpha.zip&#34;</span>
</span></span><span style=display:flex><span>WORDS_FILENAME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;words_alpha.txt&#34;</span>
</span></span><span style=display:flex><span>CLIQUES_PATH <span style=color:#f92672>=</span> PARENT_DIR <span style=color:#f92672>/</span> <span style=color:#e6db74>&#34;cliques.jsonl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>(
</span></span><span style=display:flex><span>    words_archive_path: Path <span style=color:#f92672>=</span> WORDS_ARCHIVE_PATH,
</span></span><span style=display:flex><span>    words_filename: str <span style=color:#f92672>=</span> WORDS_FILENAME,
</span></span><span style=display:flex><span>    cliques_path: Path <span style=color:#f92672>=</span> CLIQUES_PATH
</span></span><span style=display:flex><span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Load a list of words from a file (filename: word_filename) 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    within a zip archive (words_archive_path). Save a file with
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    all of the cliques (of mutually exlusive letters) to cliques_path.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    words <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        extract_archive_to_word_list(words_archive_path, words_filename)
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> get_unique_set_words_of_length_n(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    five_cliques <span style=color:#f92672>=</span> find_all_size_n_cliques(words, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> jsonlines<span style=color:#f92672>.</span>open(cliques_path, <span style=color:#e6db74>&#39;w&#39;</span>) <span style=color:#66d9ef>as</span> writer:
</span></span><span style=display:flex><span>        writer<span style=color:#f92672>.</span>write_all(five_cliques)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><p>Including the time to load in the data and construct the <code>igraph.Graph</code>, this script took 10.2 seconds on my 2019 Macbook Pro. In total, there were 538 five-word sets using 25 letters (ignoring anagrams).</p><p>Here&rsquo;s a sampling of some of the word sets:</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>chivw</td><td>enzym</td><td>fldxt</td><td>jakob</td><td>sprug</td></tr><tr><td>ampyx</td><td>crwth</td><td>fdubs</td><td>glink</td><td>vejoz</td></tr><tr><td>bortz</td><td>chivw</td><td>dunks</td><td>flegm</td><td>japyx</td></tr></tbody></table><p>Maybe I shouldn&rsquo;t be surprised that these stretch the definition of English word.</p><p>You can find the complete source for this post <a href=https://github.com/WillDuke/blog-post-code/blob/master/blog_post_code/wordle_cliques/cliques.py>here</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The source for the C implementation can be found <a href=https://github.com/igraph/igraph/blob/df17b097fd9b582241ee3f38aa82e03eba05d785/src/cliques/cliquer/cliquer.c#L337>here</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></main></body></html>